<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>AIRBNB Dashboard</title>
        <!-- Libs -->
        <script src="./js/libs/d3.min.js" charset="utf-8"></script>
        <script src="./js/libs/topojson.v1.min.js"></script>
        <script src="./js/libs/crossfilter.min.js"></script>
        <script src="./js/libs/d3-legend.min.js"></script>
        <script src="./js/libs/d3.geo.tile.js"></script>
        <script src="./js/libs/dc.min.js"></script>

        <!-- Project files -->
        <script src="./js/map.js"></script>
        <script src="./js/data-munging.js"></script>
        <link type="txt/css" rel="stylesheet" href="./css/dashboard-styles.css">

    </head>
    <body>
        <div id="airbnb-dashboard">
            <div class="chart-label">Airbnb Tahoe Market</div>
            <div id="loading"></div>
            <div id="timeline-container">
                <div class="chart-label">New Listings</div>
            </div>
            <div>
                <div id="map-container" class="ib">
                    <div class="chart-label">By location</div>
                </div>
                <div id="people-capacity" class="ib">
                    <div class="chart-label">People capacity</div>
                </div>
            </div>
        </div>
        <script>
            var overrideTimeDomain = [new Date("1/1/2013"), new Date("1/1/2015")];
            var map, byCapacity;
            initVis();

            function initVis() {
                // Fetch data
                d3.csv("../../data/listings.csv", function(error, rawData) {
                    if (error) return console.error(error);
                    var listings = mungeData(rawData);
                    makeVis(listings);

                });
            }

            function makeVis(listings) {


                map = MapChart("#map-container")
                    .width(350)
                    .height(350)
                    .key(function(d) { return d.key; })
                    .location(function(d) { return d.key; })
                    .radius(function(d) { return +d.value; })

                d3.select("#map-container")
                    .datum(listings.groups.location.top(Infinity))
                    .call(map);

                byCapacity = dc.barChart("#people-capacity")
                    .width(200)
                    .height(150)
                    .margins({top: 10, right: 10, bottom: 20, left: 40})
                    .dimension(listings.dims.capacity)
                    .group(listings.groups.capacity)
                    .x( d3.scale
                          .linear()
                          .domain([0, 17]) )
                    .elasticY(true)
                    .gap(1)
                    .centerBar(true)
                    .round(function(v) { return dc.round.floor(v) + 0.5; })
                    .alwaysUseRounding(true)
                    // .renderHorizontalGridLines(true)
                    .yAxisLabel('# listings')

                dc.renderAll();

                makeTimeline(listings);
            };

            // Creates the event timeline and sets up callbacks for brush changes
            function makeTimeline(listings) {
                var data = listings.groups.dateCreated
                    .top(Infinity)
                    .sort(function(a,b) { return a.key - b.key; }) //listings.metrics.newListingsPerDay().top(Infinity); //listings.

                var margin = { top: 30, right: 10, bottom: 20, left: 25 },
                    width  = 2*map.width() - margin.left - margin.right,
                    height = 130 - margin.top  - margin.bottom;

                var timelineSvg = d3.select("#timeline-container").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                var timeline = timelineSvg.append("g")
                    .attr("class", "timeline")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                var x = d3.time.scale()
                    .domain(overrideTimeDomain)
                    .range([0, width])
                    .clamp(true);

                var y = d3.scale.linear()
                    .domain([0, 20]) //d3.extent(data, function(d) { return +d.value; }))
                    .range([height, 0])
                    .clamp(true);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left")
                    .ticks(2);

                var area = d3.svg.area()
                    .interpolate("linear")
                    .x(function(d) { return x(d.key); })
                    .y0(height)
                    .y1(function(d) { return y(d.value); });

                timeline.append("path")
                    // .datum(dataForTimeline)
                    .datum(data)
                    .attr("class", "area")
                    .attr("d", area);

                timeline.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);

                timeline.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);

                timeline.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("dy", "1em")
                    .style("text-anchor", "end")
                    .text("New listings");

                // Add brush to timeline, hook up to callback
                var brush = d3.svg.brush()
                    .x(x)
                    .on("brush", function() {
                        brushCallback(brush, listings);
                    })
                    .extent([new Date("12/1/2014"), new Date("1/1/2015")]); // initial value

                timeline.append("g")
                    .attr("class", "x brush")
                    .call(brush)
                  .selectAll("rect")
                    .attr("y", -6)
                    .attr("height", height + 7);

                brush.event(timeline.select('g.x.brush')); // dispatches a single brush event
            };

            // Called whenever the timeline brush range (extent) is updated
            // Filters the map data to those points that fall within the selected timeline range
            function brushCallback(brush, listings) {
                listings.dims.dateCreated.filter(brush.extent())
                map.updatePoints( listings.groups.location.top(Infinity) );

                dc.redrawAll();
            }
        </script>
    </body>
</html>